{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\castr\\\\Documents\\\\GitHub\\\\radioorientefm\\\\frontend\\\\src\\\\contexts\\\\AudioContext.js\",\n  _s = $RefreshSig$();\nimport React, { createContext, useState, useRef, useEffect } from \"react\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nexport const AudioContextGlobal = /*#__PURE__*/createContext();\nexport const AudioProvider = ({\n  children\n}) => {\n  _s();\n  const audioRef = useRef(new Audio()); // Una sola instancia de audio\n  const [isPlaying, setIsPlaying] = useState(false);\n  const [volume, setVolume] = useState(() => {\n    const saved = localStorage.getItem(\"radioVolume\");\n    return saved !== null ? Number(saved) : 1;\n  });\n  const [streamUrl, setStreamUrl] = useState(null);\n\n  // Traer URL del backend SOLO UNA VEZ al cargar el componente\n  useEffect(() => {\n    const fetchStream = async () => {\n      try {\n        var _data$stream_url;\n        const res = await fetch(\"/api/radio/station/\");\n        const data = await res.json();\n\n        // Asegurarse de que streamUrl sea un string\n        const url = typeof data.stream_url === \"string\" ? data.stream_url : ((_data$stream_url = data.stream_url) === null || _data$stream_url === void 0 ? void 0 : _data$stream_url.src) || null;\n        setStreamUrl(url);\n        if (url) {\n          audioRef.current.src = url;\n          audioRef.current.volume = volume; // Setear volumen inicial\n        }\n      } catch (err) {\n        console.error(\"Error al cargar stream:\", err);\n      }\n    };\n    fetchStream();\n  }, []); // SIN 'volume' aquí - solo se ejecuta una vez\n\n  // Mantener volumen sincronizado - ESTE useEffect SÍ debe tener volume como dependencia\n  useEffect(() => {\n    if (audioRef.current) {\n      audioRef.current.volume = volume;\n      localStorage.setItem(\"radioVolume\", volume);\n    }\n  }, [volume]);\n  const togglePlay = () => {\n    if (!streamUrl) return;\n    if (isPlaying) {\n      audioRef.current.pause();\n      setIsPlaying(false);\n    } else {\n      audioRef.current.play().catch(console.error);\n      setIsPlaying(true);\n    }\n  };\n  const toggleMute = () => {\n    setVolume(prev => prev > 0 ? 0 : 1);\n  };\n  return /*#__PURE__*/_jsxDEV(AudioContextGlobal.Provider, {\n    value: {\n      audioRef,\n      isPlaying,\n      togglePlay,\n      volume,\n      setVolume,\n      toggleMute,\n      streamUrl\n    },\n    children: children\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 64,\n    columnNumber: 5\n  }, this);\n};\n_s(AudioProvider, \"A64z8uH5SQSYnIgBmYIFu9KTxjw=\");\n_c = AudioProvider;\nvar _c;\n$RefreshReg$(_c, \"AudioProvider\");","map":{"version":3,"names":["React","createContext","useState","useRef","useEffect","jsxDEV","_jsxDEV","AudioContextGlobal","AudioProvider","children","_s","audioRef","Audio","isPlaying","setIsPlaying","volume","setVolume","saved","localStorage","getItem","Number","streamUrl","setStreamUrl","fetchStream","_data$stream_url","res","fetch","data","json","url","stream_url","src","current","err","console","error","setItem","togglePlay","pause","play","catch","toggleMute","prev","Provider","value","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["C:/Users/castr/Documents/GitHub/radioorientefm/frontend/src/contexts/AudioContext.js"],"sourcesContent":["import React, { createContext, useState, useRef, useEffect } from \"react\";\r\n\r\nexport const AudioContextGlobal = createContext();\r\n\r\nexport const AudioProvider = ({ children }) => {\r\n  const audioRef = useRef(new Audio()); // Una sola instancia de audio\r\n  const [isPlaying, setIsPlaying] = useState(false);\r\n  const [volume, setVolume] = useState(() => {\r\n    const saved = localStorage.getItem(\"radioVolume\");\r\n    return saved !== null ? Number(saved) : 1;\r\n  });\r\n  const [streamUrl, setStreamUrl] = useState(null);\r\n\r\n  // Traer URL del backend SOLO UNA VEZ al cargar el componente\r\n  useEffect(() => {\r\n    const fetchStream = async () => {\r\n      try {\r\n        const res = await fetch(\"/api/radio/station/\");\r\n        const data = await res.json();\r\n\r\n        // Asegurarse de que streamUrl sea un string\r\n        const url = typeof data.stream_url === \"string\"\r\n          ? data.stream_url\r\n          : data.stream_url?.src || null;\r\n\r\n        setStreamUrl(url);\r\n\r\n        if (url) {\r\n          audioRef.current.src = url;\r\n          audioRef.current.volume = volume; // Setear volumen inicial\r\n        }\r\n      } catch (err) {\r\n        console.error(\"Error al cargar stream:\", err);\r\n      }\r\n    };\r\n\r\n    fetchStream();\r\n  }, []); // SIN 'volume' aquí - solo se ejecuta una vez\r\n\r\n  // Mantener volumen sincronizado - ESTE useEffect SÍ debe tener volume como dependencia\r\n  useEffect(() => {\r\n    if (audioRef.current) {\r\n      audioRef.current.volume = volume;\r\n      localStorage.setItem(\"radioVolume\", volume);\r\n    }\r\n  }, [volume]);\r\n\r\n  const togglePlay = () => {\r\n    if (!streamUrl) return;\r\n    if (isPlaying) {\r\n      audioRef.current.pause();\r\n      setIsPlaying(false);\r\n    } else {\r\n      audioRef.current.play().catch(console.error);\r\n      setIsPlaying(true);\r\n    }\r\n  };\r\n\r\n  const toggleMute = () => {\r\n    setVolume(prev => (prev > 0 ? 0 : 1));\r\n  };\r\n\r\n  return (\r\n    <AudioContextGlobal.Provider value={{\r\n      audioRef,\r\n      isPlaying,\r\n      togglePlay,\r\n      volume,\r\n      setVolume,\r\n      toggleMute,\r\n      streamUrl\r\n    }}>\r\n      {children}\r\n    </AudioContextGlobal.Provider>\r\n  );\r\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}